-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Parchapel where
import Abschapel
import Lexchapel
import ErrM
import Control.Monad
import EnvironmentFunctions
import TreeAddressCode
}


-----------------
--- attributi ---
-----------------
%attributetype 			{Myattr a}
%attribute parsetree 		{a}
--Tipo del nodo per controllare che il nodo sia ben formato
%attribute typ 			{Type}
--attributo per stampare errore
%attribute err			{String}
--attributi per la gestione dell'environment e label dell'environment
--envIn e' ereditato, envOut sintetizzato
--envOut ogni volta lo aggiorno inserendo nuovo id e tipo
%attribute envIn		{[Env]}
%attribute envOut		{[Env]}
--attributi per gestione environment funzioni
%attribute envInF		{[EnvF]}
%attribute envOutF		{[EnvF]}
--tipo di ritorno della funzione
%attribute typFun		{Type}
--parametri della funzione
%attribute paramList 		{[Type]}
--è una costante
%attribute isconst		{Bool}
--ambiente per le label
%attribute envInL		{[EnvL]}
%attribute envOutL		{[EnvL]}
--attributo hasReturn per verificare che funzione torni sempre
%attribute hasReturn 		{Bool}
--attributo che tiene conto se si è all'interno di un loop (per break e continue)
%attribute isInLoop		{Bool}



--attributi per il three address code
%attribute tac {[Tac]}
--indirizzi label del tac per stampare labelInt
%attribute tempLab 		{Int}
--indirizzi temporanei delle variabili per stampare tInt
%attribute tempVar		{Int}
--indirizzi label del tac per stampare labelInt in uscita
%attribute tempLabOut		{Int}
--indirizzi temporanei delle variabili per stampare tInt in uscita
%attribute tempVarOut		{Int}
--indirizzo delle variabili dichiarate per stampare identificatore di quelle variabili
%attribute addr 		{String}
--indirizzo della lista dei parametri per le chiamate di procedura
%attribute addrParamList	{[String]}
--etichetta che tiene conto dell'istruzione successiva in cui saltare
%attribute next 		{Int}
--temporaneo che memorizza la condizione expr del select per passarla ai when
%attribute tSelect		{Int}
--etichetta temporanea per memorizzare la fine del loop padre per il break
%attribute endLoop		{Int}
--etichetta temporanea per memorizzare l'inizio del loop padre per il continue
%attribute beginLoop		{Int}
--etichetta temporanea per memorizzare la fine di una procedura
%attribute endProc		{Int}
--attributo che tiene conto se un'espressione booleana è una condizione, per valutare eventualmente con short-cut
%attribute isCond		{Bool}


%name pProg Prog

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

--Precedenze
%left '..'
%left ':'
%right '#' 'by'
%left '&&'
%left '^'  
%left '||'
%left '!'
%nonassoc '='
%nonassoc '<' '<=' '==' '>' '>=' '!='
%left '+' '-'
%left '*' '/' '%'
%right NEG
%right '**'

%token 
 '!' { PT _ (TS _ 1) }
 '!=' { PT _ (TS _ 2) }
 '#' { PT _ (TS _ 3) }
 '%' { PT _ (TS _ 4) }
 '&&' { PT _ (TS _ 5) }
 '(' { PT _ (TS _ 6) }
 ')' { PT _ (TS _ 7) }
 '*' { PT _ (TS _ 8) }
 '**' { PT _ (TS _ 9) }
 '+' { PT _ (TS _ 10) }
 ',' { PT _ (TS _ 11) }
 '-' { PT _ (TS _ 12) }
 '..' { PT _ (TS _ 13) }
 '/' { PT _ (TS _ 14) }
 ':' { PT _ (TS _ 15) }
 '::' { PT _ (TS _ 16) }
 ';' { PT _ (TS _ 17) }
 '<' { PT _ (TS _ 18) }
 '<=' { PT _ (TS _ 19) }
 '=' { PT _ (TS _ 20) }
 '==' { PT _ (TS _ 21) }
 '>' { PT _ (TS _ 22) }
 '>=' { PT _ (TS _ 23) }
 '[' { PT _ (TS _ 24) }
 ']' { PT _ (TS _ 25) }
 '^' { PT _ (TS _ 26) }
 'bool' { PT _ (TS _ 27) }
 'break' { PT _ (TS _ 28) }
 'by' { PT _ (TS _ 29) }
 'catch' { PT _ (TS _ 30) }
 'char' { PT _ (TS _ 31) }
 'const' { PT _ (TS _ 32) }
 'continue' { PT _ (TS _ 33) }
 'do' { PT _ (TS _ 34) }
 'else' { PT _ (TS _ 35) }
 'false' { PT _ (TS _ 36) }
 'float' { PT _ (TS _ 37) }
 'for' { PT _ (TS _ 38) }
 'goto' { PT _ (TS _ 39) }
 'if' { PT _ (TS _ 40) }
 'in' { PT _ (TS _ 41) }
 'int' { PT _ (TS _ 42) }
 'label' { PT _ (TS _ 43) }
 'otherwise' { PT _ (TS _ 44) }
 'pointer' { PT _ (TS _ 45) }
 'proc' { PT _ (TS _ 46) }
 'ref' { PT _ (TS _ 47) }
 'repeat' { PT _ (TS _ 48) }
 'return' { PT _ (TS _ 49) }
 'select' { PT _ (TS _ 50) }
 'string' { PT _ (TS _ 51) }
 'then' { PT _ (TS _ 52) }
 'true' { PT _ (TS _ 53) }
 'try' { PT _ (TS _ 54) }
 'until' { PT _ (TS _ 55) }
 'val' { PT _ (TS _ 56) }
 'var' { PT _ (TS _ 57) }
 'when' { PT _ (TS _ 58) }
 'while' { PT _ (TS _ 59) }
 '{' { PT _ (TS _ 60) }
 '||' { PT _ (TS _ 61) }
 '}' { PT _ (TS _ 62) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_charac { PT _ (TC $$) }
L_quoted { PT _ (TL $$) }
L_Id { PT _ (T_Id $$) }
L_err    { _ }


%%
Integer : L_integ  { $$ = (read ( $1)) :: Integer }
Double  : L_doubl  { $$ = (read ( $1)) :: Double }
Char    : L_charac { $$ = (read ( $1)) :: Char }
String  : L_quoted { $$ =  $1 }
Id : L_Id { $$ = Id ($1)}


Prog : ListCmd {	$$ = (Program (reverse $1), $$.tac);
			$1.isInLoop = False;
			$$.envIn = initEnv ;
			$1.envIn = $$.envIn;
			$$.envInF = initEnvF ;
			$1.envInF = $$.envInF;
			$$.envInL = initEnv ;
			$1.envInL = $$.envInL;
			$1.tempLab = 0;
			$1.tempVar = 0;
			$1.next = 0;
			$$.tac = $1.tac;} 


-- variabili dichiarate come Var Id Type True Pass_val
--tac vuoto perchè non ho nessun operatore
Decl : 'var' ListId ':' Type ';' { 
			$$ = VarDecl $2 $4;
			$$.envOut = (addVarDecl $$.envIn (genVarList $2 $4 Pass_val)); 	
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;	
			$$.tempLabOut = $$.tempLab;
			$$.tempVarOut = $$.tempVar;
			$$.tac = [];
			where ( case (checkDeclVar $2 $$.envIn) of {
				Just a -> Bad $ "Scope Error at "++(tokenPos2 $1)++": variable or constant "++(getIdName a)++" already declared" ;
				Nothing -> Ok ();
			});}

-- variabili dichiarate come Var Id Type True Pass_val
  | 'var' ListId ':' Type '=' ExpR ';' {
			$$ =  VarDeclAss $2 $4 $6;
			$$.envOut = (addVarDecl $$.envIn (genVarList $2 $4 Pass_val)); 
			$$.envOutF = $$.envInF;	
			$$.envOutL = $$.envInL;
			$$.err = (verifyIdType $4 $6.typ $5);
			$6.envIn = $$.envIn;
			$6.envInF = $$.envInF;
			$6.tempLab = $$.tempLab;
			$6.tempVar = $$.tempVar;
			$$.tempLabOut = $6.tempLabOut;
			$$.tempVarOut = $6.tempVarOut;
			$$.isCond = False;
			$6.isCond = $$.isCond;
			$$.tac = $6.tac ++ (tacAssign $2 $6.addr);
			where ( case (checkDeclVar $2 $$.envIn) of {
				Just a -> Bad $ "Scope Error at "++(tokenPos2 $1)++": variable or constant "++(getIdName a)++" already declared";
				Nothing -> (case (verifyIdType $4 $6.typ $5) of {
						"" -> Ok();
						x  -> Bad $ x});
				}
			);
			}

-- array dichiarati come Var Id Type True Pass_ref
--viene effettuato il controllo sulle dimensioni dell'array
  | 'var' ListId ':' Type '=' '[' ListExpR ']' ';' {
			$$ = ArrDeclSing $2 $4 $7;
			$$.envOut = (addVarDecl $$.envIn (genVarList $2 $4 Pass_ref)); 
			$$.envOutF = $$.envInF;	
			$$.envOutL = $$.envInL;
			$$.err = (checkArrayExpr (verifyArrayType $4 1) $7.typ $5) ;
			$7.envIn = $$.envIn;
			$7.envInF = $$.envInF;
			$7.tempLab = $$.tempLab;
			$7.tempVar = $$.tempVar;
			$$.tempLabOut = $7.tempLabOut;
			$$.tempVarOut = $7.tempVarOut;
			$$.isCond = False;
			$7.isCond = $$.isCond;
			$$.tac = $7.tac ++ (arrayAssign 1 $2 $7.addrParamList);
			where ( case (checkDeclVar $2 $$.envIn) of {
				Just a -> Bad $ "Scope Error at "++(tokenPos2 $1)++": variable or constant "++(getIdName a)++" already declared";
				Nothing -> (case (checkArrayExpr (verifyArrayType $4 1) $7.typ $5) of {
						"" -> Ok();
						x  -> Bad $ x});
				}
			);
			}

--array multidimensionali
  | 'var' ListId ':' Type '=' '[' ListExpArrayElem ']' ';' { 
			$$ = ArrDeclMult $2 $4 $7; 
			$$.envOut = (addVarDecl $$.envIn (genVarList $2 $4 Pass_ref)); 
			$$.envOutF = $$.envInF;	
			$$.envOutL = $$.envInL;
			$$.err = (checkArrayExpr (verifyArrayType $4 (length $7)) $7.typ $5) ;
			$7.envIn = $$.envIn;
			$7.envInF = $$.envInF;
			
			$7.tempLab = $$.tempLab;
			$7.tempVar = $$.tempVar;
			$$.tempLabOut = $7.tempLabOut;
			$$.tempVarOut = $7.tempVarOut;
			$$.isCond = False;
			$7.isCond = $$.isCond;
			$$.tac = $7.tac ++ (arrayAssign 1 $2 $7.addrParamList);
			where ( case (checkDeclVar $2 $$.envIn) of {
				Just a -> Bad $ "Scope Error at "++(tokenPos2 $1)++": variable or constant "++(getIdName a)++" already declared";
				Nothing -> (case (checkArrayExpr (verifyArrayType $4 (length $7)) $7.typ $5) of {
						"" -> Ok();
						x  -> Bad $ x});
				}
			);}

--dichiarazione di costante
--implementando il passaggio per valore posso assegnare a const anche una variabile già definita
  | 'const' Id ':' Type '=' ExpR ';' { 
			$$ = ConstDecl $2 $4 $6;
			$$.envOut = (addVarDecl $$.envIn (genVarList [$2] $4 Pass_const)); 
			$$.envOutF = $$.envInF;	
			$$.envOutL = $$.envInL;
			$$.err = (verifyIdType $4 $6.typ $5);
			$6.envIn = $$.envIn;
			$6.envInF = $$.envInF;
			$6.tempLab = $$.tempLab;
			$6.tempVar = $$.tempVar;
			$$.tempLabOut = $6.tempLabOut;
			$$.tempVarOut = $6.tempVarOut;
			$$.isCond = False;
			$6.isCond = $$.isCond;
			$$.tac = $6.tac ++ (tacAssign [$2] $6.addr);
			where ( case (checkDeclVar [$2] $$.envIn) of {
				Just a -> Bad $ "Scope Error at "++(tokenPos2 $1)++": variable or constant "++(getIdName a)++" already declared";
				Nothing -> (case (verifyIdType $4 $6.typ $5) of {
						"" -> Ok();
						x  -> Bad $ x});
				}
			);}

  | 'label' Id ':' ';' {$$ = LabelDecl $2;
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = addLabelDecl $2 $$.envInL;
			$$.tempLabOut = $$.tempLab;
			$$.tempVarOut = $$.tempVar;
			$$.tac = [];
			where ( case (checkDeclLabel [$2] $$.envInL) of {
				Just a -> Bad $ "Scope Error at "++(tokenPos2 $1)++": label "++(getIdName a)++" already declared";
				Nothing -> Ok();
			});
			}


--procedura non torna niente, e con attributo typfun faccio questo controllo
--accetta return;
--aggiunto $6.isInLoop = $$.isInLoop;
  | 'proc' Id '(' ListParam ')' Cmd { 
			$$ = ProcDecl $2 $4 $6;
			$$.isInLoop = False;
			$6.isInLoop = $$.isInLoop;
			$$.envOut = $$.envIn;
			$$.envOutL = $$.envInL;
			$$.envOutF = addFunDecl $$.envInF (genFunElem $2 TypeVoid $4.paramList);
			$6.envIn = newEnvPar $$.envIn $4.envIn;
			$6.envInF = $$.envOutF;
			$6.envInL = $$.envOutL;
			$6.typFun = TypeVoid;  
			$6.tempLab = $$.tempLab;
			$6.tempVar = $$.tempVar;
			$$.tempLabOut = ($6.tempLabOut+1);
			$$.tempVarOut = $6.tempVarOut;
			$$.next = $$.tempLabOut;
			$$.endProc = $$.next;
			$6.endProc = $$.endProc;
			$$.tac = [UJump $$.next]++[DeclProc "proc" $2 (length $4.paramList)] ++ $6.tac ++ [Lab (show $$.next)];
			where (if (searchFun $2 $$.envInF) 
					then Bad $ "Scope Error at "++(tokenPos2 $1)++": function or procedure "++(getIdName $2)++" already declared"
					else Ok () );}

--quando ritorno qualcosa controlla che il tipo sia corretto
--controlla che attributo hasReturn di Cmd sia true per verificare che torni in ogni caso
--aggiunto $8.isInLoop = $$.isInLoop;
  | 'proc' Id '(' ListParam ')' ':' Type Cmd { 
			$$ = FuncDecl $2 $4 $7 $8;
			$$.isInLoop = False;
			$8.isInLoop = $$.isInLoop;
			$$.envOut = $$.envIn;
			$$.envOutL = $$.envInL;
			$$.envOutF = addFunDecl $$.envInF (genFunElem $2 $7 $4.paramList);
			$8.envIn = newEnvPar $$.envIn $4.envIn;
			$8.envInF = $$.envOutF;
			$8.envInL = $$.envOutL;
			$8.typFun = $7; 
			$8.tempLab = $$.tempLab;
			$8.tempVar = $$.tempVar;
			$$.tempLabOut = ($8.tempLabOut+1);
			$$.tempVarOut = $8.tempVarOut;
			$$.next = $$.tempLabOut;
			$$.endProc = $$.next;
			$8.endProc = $$.endProc;
			$$.tac = [UJump $$.next]++[DeclProc "proc" $2 (length $4.paramList)] ++ $8.tac ++ [Lab (show $$.next)]; 
			where (if (searchFun $2 $$.envInF) 
					then Bad $ "Scope Error at "++(tokenPos2 $1)++": function or procedure "++(getIdName $2)++" already declared"
					else when (not($8.hasReturn)) $ Bad $ "Sintax Error at "++(tokenPos2 $1)++". Missing return statement")
					;}

--parametri formali delle procedure
Param : Id ':' Type {	$$ = Param $1 $3;
			$$.envIn = genVarList [$1] $3 Pass_val;
			$$.paramList = replicate (length [$1]) $3;} 

  | Pass Id ':' Type {  $$ = PassParam $1 $2 $4;
			$$.envIn = genVarList [$2] $4 $1;
			$$.paramList = replicate ( length [$2]) $4;}

--tipi di passaggio
Pass : 'val' { $$ = Pass_val;}

  | 'ref' { $$ = Pass_ref;}

  | 'const' { $$ = Pass_const;}


ExpR : ExpRange { 	$$ = Range $1;
			$$.typ = $1.typ;			
			$1.envIn = $$.envIn;
			$1.envInF = $$.envInF;
			$1.envInL = $$.envInL;
			$$.err = $1.err;
			}

--addizione e concatenazione
  | ExpR '+' ExpR { 	$$ = ExpAdd $1 $3;
			$$.typ = getAddType $1.typ $3.typ;
			$1.envIn = $$.envIn;
			$3.envIn = $1.envIn; 
			$1.envInF = $$.envInF;
			$3.envInF = $1.envInF; 
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL; 
			$$.err = (verifyAddOp $1.typ $3.typ $1.err $3.err $2);
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempVarOut = ($3.tempVarOut + 1);
			$$.tempLabOut = $3.tempLabOut;
			$$.addr = "t" ++ (show $$.tempVarOut);
			$$.tac = $1.tac ++ $3.tac ++ [(BinOp "+" $$.addr $1.addr $3.addr)];
			where (case (verifyAddOp $1.typ $3.typ $1.err $3.err $2) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}

  | ExpR '-' ExpR { 	$$ = ExpSub $1 $3;
			$$.typ = getOpType $1.typ $3.typ;
			$1.envIn = $$.envIn;
			$3.envIn = $1.envIn; 
			$1.envInF = $$.envInF;
			$3.envInF = $1.envInF; 
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL; 
			$$.err = (verifyOp $1.typ $3.typ $1.err $3.err $2);
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempVarOut = ($3.tempVarOut + 1);
			$$.tempLabOut = $3.tempLabOut;
			$$.addr = "t" ++ (show $$.tempVarOut);
			$$.tac = $1.tac ++ $3.tac ++ [(BinOp "-" $$.addr $1.addr $3.addr)];
			where (case (verifyOp $1.typ $3.typ $1.err $3.err $2) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}

  | ExpR '*' ExpR { 	$$ = ExpMul $1 $3;
			$$.typ = getOpType $1.typ $3.typ;
			$1.envIn = $$.envIn;
			$3.envIn = $1.envIn; 
			$1.envInF = $$.envInF;
			$3.envInF = $1.envInF;
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL;  
			$$.err = (verifyOp $1.typ $3.typ $1.err $3.err $2);
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempVarOut = ($3.tempVarOut + 1);
			$$.tempLabOut = $3.tempLabOut;
			$$.addr = "t" ++ (show $$.tempVarOut);
			$$.tac = $1.tac ++ $3.tac ++ [(BinOp "*" $$.addr $1.addr $3.addr)];
			where (case (verifyOp $1.typ $3.typ $1.err $3.err $2) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}

  | ExpR '/' ExpR { 	$$ = ExpDiv $1 $3;
			$$.typ = getOpType $1.typ $3.typ;
			$1.envIn = $$.envIn;
			$3.envIn = $1.envIn; 
			$1.envInF = $$.envInF;
			$3.envInF = $1.envInF;
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL; 
			$$.err = (verifyOp $1.typ $3.typ $1.err $3.err $2);
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempVarOut = ($3.tempVarOut + 1);
			$$.tempLabOut = $3.tempLabOut;
			$$.addr = "t" ++ (show $$.tempVarOut);
			$$.tac = $1.tac ++ $3.tac ++ [(BinOp "/" $$.addr $1.addr $3.addr)];
			where (case (verifyOp $1.typ $3.typ $1.err $3.err $2) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}

--elevamento a potenza
  | ExpR '**' ExpR { 	$$ = ExpPot $1 $3;
			$$.typ = getOpType $1.typ $3.typ;
			$1.envIn = $$.envIn;
			$3.envIn = $1.envIn; 
			$1.envInF = $$.envInF;
			$3.envInF = $1.envInF;
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL; 
			$$.err = (verifyOp $1.typ $3.typ $1.err $3.err $2);
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempVarOut = ($3.tempVarOut + 1);
			$$.tempLabOut = $3.tempLabOut;
			$$.addr = "t" ++ (show $$.tempVarOut);
			$$.tac = $1.tac ++ $3.tac ++ [(BinOp "**" $$.addr $1.addr $3.addr)];
			where (case (verifyOp $1.typ $3.typ $1.err $3.err $2) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}

--modulo
  | ExpR '%' ExpR { 	$$ = ExpMod $1 $3;
			$$.typ = getOpType $1.typ $3.typ;
			$1.envIn = $$.envIn;
			$3.envIn = $1.envIn; 
			$1.envInF = $$.envInF;
			$3.envInF = $1.envInF;
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL; 
			$$.err = (verifyIntOp $1.typ $3.typ $1.err $3.err $2);
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempVarOut = ($3.tempVarOut + 1);
			$$.tempLabOut = $3.tempLabOut;
			$$.addr = "t" ++ (show $$.tempVarOut);
			$$.tac = $1.tac ++ $3.tac ++ [(BinOp "%" $$.addr $1.addr $3.addr)];
			where (case (verifyIntOp $1.typ $3.typ $1.err $3.err $2) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}

--cast non cambia il tipo della foglia expr, solo del nodo
  | ExpR ':' Type { 	$$ = ExpCast $1 $3;
			$$.typ = $3;
			$1.envIn = $$.envIn;
			$1.envInF = $$.envInF;
			$1.envInL = $$.envInL;
			$$.err = (verifyCast $1.typ $3 $1.err $2);
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$$.tempVarOut = $1.tempVarOut;
			$$.tempLabOut = $1.tempLabOut;
			$$.addr = $1.addr;
			$$.tac = $1.tac;
			where (case (verifyCast $1.typ $3 $1.err $2) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}

  | '(' ExpR ')' { 	$$ = ParExp $2;
			$$.typ = $2.typ;
			$$.err = $2.err;
			$2.envIn = $$.envIn;
			$2.envInF = $$.envInF;
			$2.envInL = $$.envInL;
			$2.tempLab = $$.tempLab;
			$2.tempVar = $$.tempVar;
			$$.tempVarOut = $2.tempVarOut;
			$$.tempLabOut = $2.tempLabOut;
			$$.addr = $2.addr;
			$$.isCond = False;
			$2.isCond = $$.isCond;
			$$.tac = $2.tac;}

  | '-' ExpR %prec NEG{ $$ = ExpNeg $2;
			$$.typ = $2.typ;
			$2.envIn = $$.envIn;
			$2.envInF = $$.envInF;
			$2.envInL = $$.envInL;
			$$.err = (verifyNum $2.typ $2.err $1);
			$2.tempLab = $$.tempLab;
			$2.tempVar = $$.tempVar;
			$$.tempVarOut = ($2.tempVarOut + 1);
			$$.tempLabOut = $2.tempLabOut;
			$$.addr = "t" ++ (show $$.tempVarOut);
			$$.tac = $2.tac++[(UnOp "-" $$.addr $2.addr)];
			where (case (verifyNum $2.typ $2.err $1) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}

  | ExpL {		$$ =  ExpLeft $1;
			$$.typ = $1.typ;
			$$.isconst = $1.isconst;
			$$.err = $1.err;
			$1.envIn = $$.envIn;
			$1.envInF = $$.envInF;
			$1.envInL = $$.envInL;
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$$.tempVarOut = $1.tempVarOut;
			$$.tempLabOut = $1.tempLabOut;
			$$.addr = $1.addr;
			$$.tac = $1.tac;}

  | Basic {		$$ = ExBasic $1;
			$$.typ = $1.typ;
			$1.envIn = $$.envIn;
			$1.envInF = $$.envInF;
			$1.envInL = $$.envInL;
			$$.err = ""; 
			$$.tempLabOut = $$.tempLab;
			$$.tempVarOut = $$.tempVar;
			$$.addr = (showBasic $1);		
			$$.tac = [];}

  | ExpR '==' ExpR {	$$ = ExpEqu $1 $3;
			$1.envIn = $$.envIn;
			$3.envIn = $1.envIn; 
			$1.envInF = $$.envInF;
			$3.envInF = $1.envInF;
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL;  
			$$.typ = TypeBool;
			$$.err = (verifyEqOp $1.typ $3.typ $1.err $3.err $2);
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempVarOut = ($3.tempVarOut + 1);
			$$.tempLabOut = $3.tempLabOut;
			$$.addr = "t" ++ (show $$.tempVarOut);
			$$.tac = $1.tac ++ $3.tac ++ [(BinOp "==" $$.addr $1.addr $3.addr)];
			where ( case (verifyEqOp $1.typ $3.typ $1.err $3.err $2) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}

  | ExpR '<' ExpR { 	$$ = ExpLes $1 $3;
			$1.envIn = $$.envIn;
			$3.envIn = $1.envIn; 
			$1.envInF = $$.envInF;
			$3.envInF = $1.envInF;
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL;  
			$$.typ = TypeBool;
			$$.err = (verifyOp $1.typ $3.typ $1.err $3.err $2);
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempVarOut = ($3.tempVarOut + 1);
			$$.tempLabOut = $3.tempLabOut;
			$$.addr = "t" ++ (show $$.tempVarOut);
			$$.tac = $1.tac ++ $3.tac ++ [(BinOp "<" $$.addr $1.addr $3.addr)];
			where ( case (verifyOp $1.typ $3.typ $1.err $3.err $2) of {
				"" -> Ok();
				x  -> Bad $ x;
			}); }

  | ExpR '<=' ExpR { 	$$ = ExpLeq $1 $3;
			$1.envIn = $$.envIn;
			$3.envIn = $1.envIn; 
			$1.envInF = $$.envInF;
			$3.envInF = $1.envInF; 
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL; 
			$$.typ = TypeBool;
			$$.err = (verifyOp $1.typ $3.typ $1.err $3.err $2);
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempVarOut = ($3.tempVarOut + 1);
			$$.tempLabOut = $3.tempLabOut;
			$$.addr = "t" ++ (show $$.tempVarOut);
			$$.tac = $1.tac ++ $3.tac ++ [(BinOp "<=" $$.addr $1.addr $3.addr)];
			where ( case (verifyOp $1.typ $3.typ $1.err $3.err $2) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}

  | ExpR '>' ExpR { 	$$ = ExpGre $1 $3;
			$1.envIn = $$.envIn;
			$3.envIn = $1.envIn; 
			$1.envInF = $$.envInF;
			$3.envInF = $1.envInF;
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL;  
			$$.typ = TypeBool;
			$$.err = (verifyOp $1.typ $3.typ $1.err $3.err $2);
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempVarOut = ($3.tempVarOut + 1);
			$$.tempLabOut = $3.tempLabOut;
			$$.addr = "t" ++ (show $$.tempVarOut);
			$$.tac = $1.tac ++ $3.tac ++ [(BinOp ">" $$.addr $1.addr $3.addr)];
			where ( case (verifyOp $1.typ $3.typ $1.err $3.err $2) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}

  | ExpR '>=' ExpR { 	$$ = ExpGrq $1 $3;
			$1.envIn = $$.envIn;
			$3.envIn = $1.envIn; 
			$1.envInF = $$.envInF;
			$3.envInF = $1.envInF;
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL;  
			$$.typ = TypeBool;
			$$.err = (verifyOp $1.typ $3.typ $1.err $3.err $2);
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempVarOut = ($3.tempVarOut + 1);
			$$.tempLabOut = $3.tempLabOut;
			$$.addr = "t" ++ (show $$.tempVarOut);
			$$.tac = $1.tac ++ $3.tac ++ [(BinOp ">=" $$.addr $1.addr $3.addr)];
			where ( case (verifyOp $1.typ $3.typ $1.err $3.err $2) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}

--diverso confronta tutto, stampo err solo se le expr hanno err
  | ExpR '!=' ExpR { 	$$ = ExpNEq $1 $3;
			$1.envIn = $$.envIn;
			$3.envIn = $1.envIn; 
			$1.envInF = $$.envInF;
			$3.envInF = $1.envInF;
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL;  
			$$.typ = TypeBool;
			$$.err = "";
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempVarOut = ($3.tempVarOut + 1);
			$$.tempLabOut = $3.tempLabOut;
			$$.addr = "t" ++ (show $$.tempVarOut);
			$$.tac = $1.tac ++ $3.tac ++ [(BinOp "!=" $$.addr $1.addr $3.addr)];
			where ( case (verifyNEqOp $1.err $3.err) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}

--and valutato con short-cut nel tac
  | ExpR '&&' ExpR { 	$$ = ExpAnd $1 $3;
			$1.envIn = $$.envIn;
			$3.envIn = $1.envIn; 
			$1.envInF = $$.envInF;
			$3.envInF = $1.envInF; 
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL; 
			$$.typ = TypeBool;
			$$.err = (verifyBoolExp $1.typ $3.typ $1.err $3.err $2);

			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempVarOut = ($3.tempVarOut + 1);
			$$.tempLabOut = $3.tempLabOut;
			$$.addr = "t" ++ (show $$.tempVarOut);
			$1.next = $$.next;
			$3.next = $$.next;
			$1.isCond = $$.isCond;
			$3.isCond = $$.isCond;
			$$.tac = if ($$.isCond) then $1.tac ++ [JumpNot $1.addr $$.next]++ $3.tac++[(BinOp "&&" $$.addr $1.addr $3.addr)] 
				else $1.tac ++ $3.tac ++[(BinOp "||" $$.addr $1.addr $3.addr)];
			where ( case (verifyBoolExp $1.typ $3.typ $1.err $3.err $2) of {
				"" -> Ok();
				x  -> Bad $ x;
			}); }

--xor
  | ExpR '^' ExpR { 	$$ = ExpXor $1 $3;
			$1.envIn = $$.envIn;
			$3.envIn = $1.envIn; 
			$1.envInF = $$.envInF;
			$3.envInF = $1.envInF; 
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL; 
			$$.typ = TypeBool;
			$$.err = (verifyBoolExp $1.typ $3.typ $1.err $3.err $2);
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempVarOut = ($3.tempVarOut + 1);
			$$.tempLabOut = $3.tempLabOut;
			$$.addr = "t" ++ (show $$.tempVarOut);
			$$.tac = $1.tac ++ $3.tac ++ [(BinOp "^" $$.addr $1.addr $3.addr)];
			where ( case (verifyBoolExp $1.typ $3.typ $1.err $3.err $2) of {
				"" -> Ok();
				x  -> Bad $ x;
			}); }

--or valutato con short-cut nel tac
  | ExpR '||' ExpR { 	$$ = ExpOr $1 $3;
			$1.envIn = $$.envIn;
			$3.envIn = $1.envIn; 
			$1.envInF = $$.envInF;
			$3.envInF = $1.envInF; 
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL; 
			$$.typ = TypeBool;
			$$.err = (verifyBoolExp $1.typ $3.typ $1.err $3.err $2);
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempVarOut = ($3.tempVarOut + 1);
			$$.tempLabOut = $3.tempLabOut;
			$$.addr = "t" ++ (show $$.tempVarOut);
			$1.isCond = $$.isCond;
			$3.isCond = $$.isCond;
			$$.tac = if ($$.isCond) then $1.tac++[Jump $1.addr ($$.tempLabOut+1)]++ $3.tac ++[(BinOp "||" $$.addr $1.addr $3.addr)]
				 else $1.tac ++ $3.tac ++[(BinOp "||" $$.addr $1.addr $3.addr)];
			where ( case (verifyBoolExp $1.typ $3.typ $1.err $3.err $2) of {
				"" -> Ok();
				x  -> Bad $ x;
			}); }

  | '!' ExpR { 		$$ = ExpNot $2;
			$2.envIn = $$.envIn;
			$2.envInF = $$.envInF;
			$2.envInL = $$.envInL;
			$$.typ = TypeBool;
			$$.err = (verifyBoolUnExp $2.typ $2.err $1);
			$2.tempLab = $$.tempLab;
			$2.tempVar = $$.tempVar;
			$$.tempVarOut = ($2.tempVarOut + 1);
			$$.tempLabOut = $2.tempLabOut;
			$$.addr = "t" ++ (show $$.tempVarOut);
			$$.tac = $2.tac++[(UnOp "!" $$.addr $2.addr)];
			where ( case (verifyBoolUnExp $2.typ $2.err $1) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}
--chiamata di funzione
  | Id '(' ListExpR ')' { 
			$$ = FunExp $1 $3;
			$3.envIn = $$.envIn;
			$3.envInF = $$.envInF;
			$$.typ = getTypeFun (getFun $1 $$.envInF);
			$$.paramList = $3.paramList;
			$$.err = checkErrFun $3.err $1 $$.envInF $3.paramList $2;
			$3.tempLab = $$.tempLab;
			$3.tempVar = $$.tempVar;
			$$.tempVarOut = if ($$.typ == TypeVoid) then ($3.tempVarOut) else ($3.tempVarOut +1);
			$$.tempLabOut = ($3.tempLabOut+1);
			$$.next = $$.tempLabOut;
			$$.isCond = False;
			$3.isCond = $$.isCond;
			$$.addr = if ($$.typ == TypeVoid) then "" else ("t" ++ (show $$.tempVarOut));
			$$.tac = if ($$.typ == TypeVoid) then $3.tac ++ [ProcCall "proc" "" $1 $3.addrParamList]++ [Lab (show $$.next)]
							 else $3.tac ++ [ProcCall "proc" ($$.addr++" =  ") $1 $3.addrParamList] ++ [Lab (show $$.next)];
			where (case (checkErrFun $3.err $1 $$.envInF $3.paramList $2) of {
						"" -> Ok ();
						x -> Bad $ x; 				
					});}


ExpRange : ExpR '..' ExpR { 
			$$ = ExpRange $1 $3;
			$$.typ = TypeRange;
			$1.envIn = $$.envIn;
			$1.envInF = $$.envInF;
			$3.envIn = $$.envIn;
			$3.envInF = $$.envInF;
			$$.err = checkIntParam $1.typ $3.typ $2;
			
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempLabOut = $3.tempLabOut;
			$$.tempVarOut = ($3.tempVarOut+1);
			$$.addr = "t" ++ (show $$.tempVarOut);
			$$.tac = $1.tac ++ $3.tac ++ [BinOp ".." $$.addr $1.addr $3.addr];
			where ( case (checkIntParam $1.typ $3.typ $2) of {		
				"" -> ( Ok () );
				a  -> ( Bad $ a);
			} );						
			} 

ExpArrayElem : '[' ListExpR ']' { 
			$$ = ExpArrayElem $2;
			$$.typ = $2.typ;			
			$2.envIn = $$.envIn;
			$2.envInF = $$.envInF;
			$2.envInL = $$.envInL;
			$$.err = $2.err; 
			$2.tempLab = $$.tempLab;
			$2.tempVar = $$.tempVar;
			$$.tempLabOut = $2.tempLabOut;
			$$.tempVarOut = $2.tempVarOut;
			$$.next = $$.tempLabOut;
			$$.isCond = False;
			$2.isCond = $$.isCond;
			$$.addrParamList = $2.addrParamList;
			$$.tac = $2.tac;} 

--definisco anche err per non mandare TypeError a $$.typ
ExpL : Id { 		$$ = NameExp $1;
			$$.typ = (getVarType $1 $$.envIn);
			$$.isconst = getIsConst $1 $$.envIn; 
			$$.err = if (not(searchVar $1 $$.envIn)) 
					then  "Scope Error : Variable  "++(getIdName $1)++" not in scope"
					else "";
			$$.tempLabOut = $$.tempLab;
			$$.tempVarOut = $$.tempVar;
			$$.addr = getIdName $1;
			$$.tac = [];
			where ( if (not(searchVar $1 $$.envIn)) 
				then ( Bad $ "Scope Error : Variable  "++(getIdName $1)++" not in scope")
				else ( Ok ()) 
				);}

--richiamo array
--controllare che gli indici siano tanti quanti i range e compresi 
  | ExpL '[' ListExpR ']' { 
			$$ = ArrExp $1 $3;
			$$.typ = getTypeArray $1.typ;
			$$.isconst = $1.isconst;
			$1.envIn = $$.envIn;
			$3.envIn = $$.envIn;
			$3.envInF = $$.envInF;
			$$.err = (verifyArray $1.typ $3.typ $1.err $3.err $2);
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $$.tempLab;
			$3.tempVar = $$.tempVar;
			$$.tempLabOut = $3.tempLabOut;
			$$.tempVarOut = ($3.tempVarOut + 2);
			$$.addr = $1.addr ++  "[" ++ (printParamArray $3.tempVarOut (length $3.addrParamList))++"]" ;
			$$.tac = $1.tac ++ $3.tac ++ (arrayTemp ($3.tempVarOut + 1) $3.addrParamList $$.typ);
			where ( case (verifyArray $1.typ $3.typ $1.err $3.err $2) of {
				"" -> Ok();
				x  -> Bad $ x;
			}); }

Basic : Integer { 	$$ = Int $1;
			$$.typ = TypeInt;
			} 

  | Double { 		$$ = Float $1;
			$$.typ = TypeFloat;
			}

  | Char {		$$ = Char $1;
			$$.typ = TypeChar;
			}

  | String { 		$$ = String $1;
			$$.typ = TypeString;
			}

  | Boolean { 		$$ = Bool $1;
			$$.typ = TypeBool;
			}


Boolean : 'true' { 	$$ = BoolTrue;
			}
 
  | 'false' { 		$$ = BoolFalse;
			}



Type : 'int' { 		$$ = TypeInt;
			$$.typ = $$;
			}
 
  | 'float' { 		$$ = TypeFloat;
			$$.typ = $$;
			}

  | 'char' { 		$$ = TypeChar;
			$$.typ = $$;
			}

  | 'string' { 		$$ = TypeString;
			$$.typ = $$;
			}

  | 'bool' { 		$$ = TypeBool;
			$$.typ = $$;
			}

  | 'pointer' Type { 	$$ = TypePointer $2;
			$$.typ = $$;
			}

  | '[' ListExpRange ']' Type { 
			$$ = TypeArray $2 $4;
			$$.typ = $$;
			}



--singolo comando
Cmd : CommSing { 	$$ = CmdSing $1;
			$1.isInLoop = $$.isInLoop;
			$$.typ = $1.typ;
			$$.hasReturn = $1.hasReturn;
			$1.envIn = $$.envIn;
			$$.envOut = $1.envOut;
			$1.envInF = $$.envInF;
			$$.envOutF = $1.envOutF;
			$1.envInL = $$.envInL;
			$$.envOutL = $1.envOutL;
			$1.typFun = $$.typFun;
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$$.tempLabOut = $1.tempLabOut;
			$$.tempVarOut = $1.tempVarOut;
			$1.next = $$.next;
			$$.next = $$.tempLabOut;
			$1.beginLoop = $$.beginLoop;
			$1.endLoop = $$.endLoop;
			$1.endProc = $$.endProc;
			$$.tac = $1.tac;}

--comandi multipli
  | '{' ListCmd '}' { 	$$ = CmdMult (reverse $2);
			$2.isInLoop = $$.isInLoop;
			$$.typ = $2.typ;
			$$.hasReturn = $2.hasReturn;
			$2.envIn = $$.envIn;
			$$.envOut = $2.envOut;
			$2.envInF = $$.envInF;
			$$.envOutF = $2.envOutF;
			$2.envInL = $$.envInL;
			$$.envOutL = $2.envOutL;
			$2.typFun = $$.typFun;
			$2.tempLab = $$.tempLab;
			$2.tempVar = $$.tempVar;
			$$.tempLabOut = $2.tempLabOut;
			$$.tempVarOut = $2.tempVarOut;
			$2.next = $$.next;
			$$.next = $$.tempLabOut;
			$2.beginLoop = $$.beginLoop;
			$2.endLoop = $$.endLoop;
			$2.endProc = $$.endProc;
			$$.tac = $2.tac;}

--comandi vari
CommSing : ExpR ';' { 	$$ = CmdExpR $1;
			$$.typ = $1.typ;
			$$.hasReturn = False;
			$1.envIn = $$.envIn;
			$$.envOut = $1.envIn;
			$1.envInF = $$.envInF;
			$$.envOutF = $$.envInF;
			$1.envInL = $$.envInL;
			$$.envOutL = $$.envInL;
			$$.err = $1.err;
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$$.tempLabOut = $1.tempLabOut;
			$$.tempVarOut = $1.tempVarOut;
			$$.next = $$.tempLabOut;
			$$.isCond = False;
			$1.isCond = $$.isCond;
			$$.tac = $1.tac;
			where (if ($$.err == "") 
					then Ok () 
					else Bad $ $$.err);}

--label
  | Id '::' { 		$$ = CmdWLabel $1; 
			$$.typ = $1.typ; 
			$$.hasReturn = False;
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;	
			$$.envOutL = $$.envInL;
			$$.tempLabOut = ($$.tempLab);
			$$.tempVarOut = $$.tempVar;
			$$.addr = (getIdName $1);
			$$.next = $$.tempLabOut;
			$$.tac = [Lab (" "++$$.addr)];
			where ( case (searchLabel $1 $$.envInL) of {
				Just a -> Bad $ "Scope Error at "++(tokenPos2 $2)++": label "++(getIdName a)++" not declared" ;
				Nothing -> Ok ();
			});}

--if then 
  | 'if' '(' ExpR ')' 'then' Cmd { 
			$$ = CmdIf $3 $6;
			$6.isInLoop = $$.isInLoop;
			$$.hasReturn = $6.hasReturn;
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;
			$3.envIn = $$.envIn;
			$3.envInF = $$.envInF;
			$3.envInL = $$.envInL;
			$6.envIn = (newEnv $$.envIn);
			$6.envInF = $$.envInF;
			$6.envInL = $$.envInL;
			$6.typFun = $$.typFun;

			$3.tempLab = $$.tempLab;
			$3.tempVar = $$.tempVar;
			$6.tempLab = ($3.tempLabOut+1);
			$6.tempVar = $3.tempVarOut;
			$$.tempLabOut = ($6.tempLabOut + 1);
			$$.tempVarOut = $6.tempVarOut;
			$3.next = $$.next;
			$6.next = $$.next;
			$$.next = $$.tempLabOut;
			$6.beginLoop = $$.beginLoop;
			$6.endLoop = $$.endLoop;
			$6.endProc = $$.endProc;
			$$.isCond = True;
			$3.isCond = $$.isCond;
			$$.tac = $3.tac ++ [Jump $3.addr ($6.tempLab)]++[JumpNot $3.addr ($$.next)]
					++ [Lab (show $6.tempLab)] ++ $6.tac ++[Lab (show $$.next)];
			where (case (verifyIfCond $3.typ $3.err $1) of {
				"" -> Ok();
				x  -> Bad $ x;
			});
				}

--if then else
--controllare quando sono annidati come vengono associati e modificare il pretty printer
  | 'if' '(' ExpR ')' 'then' Cmd 'else' Cmd { 
			$$ = CmdIfElse $3 $6 $8;
			$6.isInLoop = $$.isInLoop;
			$8.isInLoop = $$.isInLoop;
			$$.hasReturn = ($6.hasReturn && $8.hasReturn); 
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;
			$3.envIn = $$.envIn;
			$3.envInF = $$.envInF;
			$3.envInL = $$.envInL;
			$6.envIn = (newEnv $$.envIn);
			$6.envInF = $$.envInF;
			$6.envInL = $$.envInL;
			$6.typFun = $$.typFun;
			$8.envIn = (newEnv $$.envIn);
			$8.envInF = $$.envInF;
			$8.envInL = $$.envInL;
			$8.typFun = $$.typFun;

			$3.tempLab = $$.tempLab;
			$3.tempVar = $$.tempVar;
			$6.tempLab = ($3.tempLabOut+1);
			$6.tempVar = $3.tempVarOut;
			$8.tempLab = ($6.tempLabOut+1);
			$8.tempVar = $6.tempVarOut;
			$$.tempLabOut = ($8.tempLabOut+1);
			$$.tempVarOut = $8.tempVarOut;
			$3.next = $8.tempLab;
			$6.next = $$.next;
			$8.next = $$.next;
			$$.next = $$.tempLabOut;
			$6.beginLoop = $$.beginLoop;
			$8.beginLoop = $$.beginLoop;
			$6.endLoop = $$.endLoop;
			$8.endLoop = $$.endLoop;
			$6.endProc = $$.endProc;
			$8.endProc = $$.endProc;
			$$.isCond = True;
			$3.isCond = $$.isCond;
			$$.tac = $3.tac ++ [Jump $3.addr ($6.tempLab)] ++[JumpNot $3.addr ($8.tempLab)]
					++ [Lab (show ($6.tempLab ))] ++ $6.tac ++ [UJump ($$.next)]
 					++ [Lab (show ($8.tempLab))] ++ $8.tac++[Lab (show $$.next)];
			where (case (verifyIfCond $3.typ $3.err $1) of {
				"" -> Ok();
				x  -> Bad $ x;
			});
			}

  | 'while' '(' ExpR ')' BlockLoop { 
			$$ = CmdWhile $3 $5; 
			$5.isInLoop = True;
			$$.hasReturn = $5.hasReturn;
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;
			$3.envIn = $$.envIn;
			$3.envInF = $$.envInF;
			$3.envInL = $$.envInL;
			$5.envIn = (newEnv $$.envIn);
			$5.envInF = $$.envInF;
			$5.envInL = $$.envInL;
			$5.typFun = $$.typFun;

			$3.tempLab = $$.tempLab;
			$3.tempVar = $$.tempVar;
			$5.tempLab = ($3.tempLabOut+1);
			$5.tempVar = $3.tempVarOut;
			$$.tempLabOut = ($5.tempLabOut + 1);
			$$.tempVarOut = $5.tempVarOut;
			$5.next = ($$.tempLab);
			$$.next = $$.tempLabOut;
			$$.beginLoop = $5.tempLab;
			$5.beginLoop = $$.beginLoop;
			$$.endLoop = $$.next;
			$5.endLoop = $$.next;
			$5.endProc = $$.endProc;
			$$.isCond = True;
			$3.isCond = $$.isCond;
			$$.tac = [Lab (show $5.tempLab)]++$3.tac ++ [JumpNot $3.addr ($$.next)] ++ $5.tac ++ [UJump ($5.tempLab)] ++[Lab (show $$.next)];
			where (case (verifyIfCond $3.typ $3.err $1) of {
				"" -> Ok();
				x  -> Bad $ x;
			});
			}

--repeat until
  | 'repeat' Cmd 'until' '(' ExpR ')' ';' { 
			$$ = CmdDoWhile $2 $5; 
			$2.isInLoop = True;
			$$.hasReturn = $2.hasReturn;
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;
			$2.envIn = (newEnv $$.envIn);
			$2.envInF = $$.envInF;
			$2.envInL = $$.envInL;
			$2.typFun = $$.typFun;
			$5.envIn = $$.envIn;
			$5.envInF = $$.envInF;
			$5.envInL = $$.envInL;

			$2.tempLab = $$.tempLab;
			$2.tempVar = $$.tempVar;
			$5.tempLab = ($2.tempLabOut+1);
			$5.tempVar = $2.tempVarOut;
			$$.tempLabOut = ($5.tempLabOut);
			$$.tempVarOut = $5.tempVarOut;
			$$.next = $$.tempLabOut;
			$$.beginLoop = $2.tempLab;
			$2.beginLoop = $$.beginLoop;
			$$.endLoop = $$.next;
			$2.endLoop = $$.endLoop;
			$2.endProc = $$.endProc;
			$$.isCond = True;
			$3.isCond = $$.isCond;
			$$.tac = [Lab (show $5.tempLab)]++ $2.tac ++  $5.tac ++ [Jump $5.addr ($5.tempLab)];
			where (case (verifyIfCond $5.typ $5.err $1) of {
				"" -> Ok();
				x  -> Bad $ x;
			});
			}

--for completo
--aggiorno env con nuovo id in modo da poter usare indice all'interno del for
--l'indice deve essere un id a cui sarà automaticamente assegnato un valore del range
--nel tac usare operazione ausiliaria per stampare "if id in range"
--by e # non vengono valutati dal tac
  | 'for' Id 'in' ExpRange ExpFor BlockLoop { 
			$$ = CmdFor $2 $4 $5 $6; 
			$6.isInLoop = True;
			$$.hasReturn = $6.hasReturn;
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;
			$4.envIn = $$.envIn;
			$4.envInF = $$.envInF;
			$4.envInL = $$.envInL;
			$5.envIn = $$.envIn;
			$5.envInF = $$.envInF;
			$5.envInL = $$.envInL;
			$6.envIn = (addVarDecl (newEnv $$.envIn) (genVarList [$2] TypeInt Pass_val));
			$6.envInF = $$.envInF;
			$6.envInL = $$.envInL;
			$6.typFun = $$.typFun;
			
			$4.tempLab = ($$.tempLab+1);
			$4.tempVar = $$.tempVar;
			$6.tempLab = ($4.tempLabOut+1);
			$6.tempVar = $4.tempVarOut;
			$$.tempLabOut = ($6.tempLabOut+1);
			$$.tempVarOut = $6.tempVarOut;
			$$.next = $$.tempLabOut;
			$$.beginLoop = $6.tempLab;
			$6.beginLoop = $$.beginLoop;
			$$.endLoop = $$.next;
			$6.endLoop = $$.endLoop;
			$6.endProc = $$.endProc;
			$$.addr = ("t"++(show $4.tempVarOut));
			$$.tac = $4.tac++[Lab (show $4.tempLab)]++ [BinOp "in" $$.addr (getIdName $2) $4.addr]++
				 [Jump $$.addr $6.tempLab]++[JumpNot $$.addr $$.next]++[Lab (show $6.tempLab)]++
				 $6.tac ++ [UJump ($4.tempLab)]++[Lab (show $$.next)];
			where (case (verifyFor $2 $$.envIn $4.typ $4.err $5.typ $5.err $1) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}

--nel tac usare operazione ausiliaria per stampare "if id in range"
--for breve
  | 'for' Id 'in' ExpRange BlockLoop { 
			$$ = CmdForSimple $2 $4 $5; 
			$5.isInLoop = True;
			$$.hasReturn = $5.hasReturn;
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;
			
			$4.envIn = $$.envIn;
			$4.envInF = $$.envInF;
			$4.envInL = $$.envInL;
			
			$5.envIn = (addVarDecl (newEnv $$.envIn) (genVarList [$2] TypeInt Pass_val));
			$5.envInF = $$.envInF;
			$5.envInL = $$.envInL;
			$5.typFun = $$.typFun;

			$4.tempLab = ($$.tempLab+1);
			$4.tempVar = $$.tempVar;
			$5.tempLab = ($4.tempLabOut+1);
			$5.tempVar = $4.tempVarOut;
			$$.tempLabOut = ($5.tempLabOut+1);
			$$.tempVarOut = $5.tempVarOut;
			$$.next = $$.tempLabOut;
			$$.beginLoop = $5.tempLab;
			$5.beginLoop = $$.beginLoop;
			$$.endLoop = $$.next;
			$5.endLoop = $$.endLoop;
			$5.endProc = $$.endProc;
			$$.addr = ("t"++(show $4.tempVarOut));
			$$.tac = $4.tac++[Lab (show $4.tempLab)] ++ [BinOp "in" $$.addr (getIdName $2) $4.addr]++
				 [Jump $$.addr $5.tempLab]++[JumpNot $$.addr $$.next]++[Lab (show $5.tempLab)]++
				 $5.tac ++ [UJump ($4.tempLab)]++[Lab (show $$.next)];
			where (case (verifyFor $2 $$.envIn $4.typ $4.err TypeInt "" $1) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}

--select equivalente a case
--next di listWhen = next select
--next di ogni when = when succ
--il confronto avviene tra l'expr del select e del when, grazie al tSelect che porta giù il temporaneo corretto
  | 'select' ExpR '{' ListWhen '}' { 
			$$ = CmdSelect $2 (reverse $4); 
			$4.isInLoop = True;
			$$.hasReturn = $4.hasReturn;
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;
			$2.envIn = $$.envIn;
			$2.envInF = $$.envInF;
			$2.envInL = $$.envInL;
			$4.envIn = $$.envIn;
			$4.envInF = $$.envInF;
			$4.envInL = $$.envInL;
			$4.typFun = $$.typFun;

			$2.tempLab = $$.tempLab;
			$2.tempVar = $$.tempVar;
			$4.tempLab = ($2.tempLabOut);
			$4.tempVar = $2.tempVarOut;
			$$.tempLabOut = ($4.tempLabOut);
			$$.tempVarOut = $4.tempVarOut;
			$4.tSelect = $2.tempVarOut;
			$$.next = $$.tempLabOut;
			$4.next = $$.next;
			$$.beginLoop = $4.tempLab;
			$4.beginLoop = $$.beginLoop;
			$$.endLoop = $$.next;
			$4.endLoop = $$.endLoop;
			$4.endProc = $$.endProc;
			$$.isCond = False;
			$2.isCond = $$.isCond;
			$$.tac = $2.tac++$4.tac++[Lab (show $$.next)];
			where (case (verifyEqOp $2.typ $4.typ $2.err $4.err $1) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}

--select con otherwise
  | 'select' ExpR '{' ListWhen 'otherwise' Cmd '}' { 
			$$ = CmdSelectOther $2 (reverse $4) $6; 
			$4.isInLoop = True;
			$6.isInLoop = True;
			$$.hasReturn = ($4.hasReturn && $6.hasReturn);
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;
			$2.envIn = $$.envIn;
			$2.envInF = $$.envInF;
			$2.envInL = $$.envInL;
			$4.envIn = $$.envIn;
			$4.envInF = $$.envInF;
			$4.envInL = $$.envInL;
			$4.typFun = $$.typFun;
			$6.envIn = $$.envIn;
			$6.envInF = $$.envInF;
			$6.envInL = $$.envInL;
			$6.typFun = $$.typFun;

			$2.tempLab = $$.tempLab;
			$2.tempVar = $$.tempVar;
			$4.tempLab = ($2.tempLabOut);
			$4.tempVar = $2.tempVarOut;
			$6.tempLab = ($4.tempLabOut);
			$6.tempVar = $4.tempVarOut;
			$$.tempLabOut = ($6.tempLabOut+1 );
			$$.tempVarOut = $6.tempVarOut;
			$$.next = $$.tempLabOut;
			$4.tSelect = $2.tempVarOut;
			$4.next = $$.next;
			$6.next = $$.next;
			$$.beginLoop = $4.tempLab;
			$4.beginLoop = $$.beginLoop;
			$6.beginLoop = $$.beginLoop;
			$$.endLoop = $$.next;
			$4.endLoop = $$.endLoop;
			$6.endLoop = $$.endLoop;
			$4.endProc = $$.endProc;
			$6.endProc = $$.endProc;
			$$.isCond = False;
			$2.isCond = $$.isCond;
			$$.tac = $2.tac++$4.tac++[Lab (show $4.tempLab)]++$6.tac++[Lab (show $$.next)];
			where (case (verifyEqOp $2.typ $4.typ $2.err $4.err $1) of {
				"" -> Ok();
				x  -> Bad $ x;
			});}

--assegnamento
--viene attuato cast implicito da int a float e da char a string
  | ExpL '=' ExpR ';' { $$ = CmdAsgn $1 $3; 
			$$.hasReturn = False;
			$$.typ = $1.typ; 
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;	
			$$.envOutL = $$.envInL;
			$1.envIn = $$.envIn;
			$3.envIn = $$.envIn;
			$1.envInF = $$.envInF;
			$3.envInF = $$.envInF;
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL;

			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempLabOut = $3.tempLabOut;
			$$.tempVarOut = $3.tempVarOut;
			$$.next = $$.tempLabOut;
			$$.isCond = False;
			$3.isCond = $$.isCond;
			$$.tac = $1.tac ++ $3.tac ++ [ AssignOp $1.addr $3.addr];
			where ( case (assTypeError $1.typ $1.isconst $3.typ $1.err $3.err $2) of {
				"" -> Ok();
				x  -> Bad $ x;
			}); }

  | Decl { 		$$ = CmdDecl $1;
			$$.hasReturn = False;
			$1.envIn = $$.envIn;
			$$.envOut = $1.envOut;
			$1.envInF = $$.envInF;
			$$.envOutF = $1.envOutF;
			$1.envInL = $$.envInL;
			$$.envOutL = $1.envOutL;
			$1.typFun = $$.typFun;
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$$.tempLabOut = $1.tempLabOut;
			$$.tempVarOut = $1.tempVarOut;
			$$.next = $$.tempLabOut;
			$$.tac = $1.tac;}

--goto
  | 'goto' Id ';' {  	$$ = CmdGoTo $2; 
			$$.hasReturn = False;
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;

			$$.tempLabOut = $$.tempLab;
			$$.tempVarOut = $$.tempVar;
			$$.tac = [Goto (getIdName $2)];
			where (case (searchLabel $2 $$.envInL) of {
				Nothing -> Ok();
				Just a -> Bad $ ("Scope error at: " ++ (tokenPos2 $1) ++". Label not declared");
			});}

--manca l'istruzione per saltare dalla procedura al programma principale
  | 'return' ExpR ';' { $$ = CmdReturnFun $2;
			$$.hasReturn = True; 
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;
			$2.envIn = $$.envIn;
			$2.envInF = $$.envInF;
			$2.envInL = $$.envInL;
			$2.tempLab = $$.tempLab;
			$2.tempVar = $$.tempVar;
			$$.tempLabOut = $2.tempLabOut;
			$$.tempVarOut = $2.tempVarOut;
			$$.isCond = False;
			$2.isCond = $$.isCond;
			$$.tac = $2.tac++[UJump $$.endProc];
			where (case (verifyEqOp $2.typ $$.typFun $2.err "" $1) of {
				"" -> Ok();
				x  -> Bad $ ("Return type error at: " ++ (tokenPos2 $1) ++". Given: "++(showTypeName $2.typ)++". Expected: "++(showTypeName $$.typFun)) ;
			});}

  | 'return' ';' {	$$ = CmdReturnProc;
			$$.hasReturn = False;
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;
		
			$$.tempLabOut = $$.tempLab;
			$$.tempVarOut = $$.tempVar;
			$$.tac = [UJump $$.endProc];
			where (case (verifyEqOp TypeVoid $$.typFun "" "" $1) of {
				"" -> Ok();
				x  -> Bad $ ("Return type error at: " ++ (tokenPos2 $1) ++". Given: Void. Expected: "++(showTypeName $$.typFun)) ;
			});}

--break e continue
--controllo se i comandi break e continue sono all'interno di loop
  | 'break' ';' {	$$ = CmdBreak;
			$$.hasReturn = False;
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;
		
			$$.tempLabOut = $$.tempLab;
			$$.tempVarOut = $$.tempVar;
			$$.tac = [UJump $$.endLoop];
			where (if ($$.isInLoop) then Ok()
				else Bad $ ("Error at" ++ (tokenPos2 $1) ++". Break statement not in loop") 
			);}

--continue fa tornare all'inizio del ciclo
  | 'continue' ';' { 	$$ = CmdContinue; 
			$$.hasReturn = False;
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;

			$$.tempLabOut = $$.tempLab;
			$$.tempVarOut = $$.tempVar;
			$$.tac = [UJump $$.beginLoop];
			where (if ($$.isInLoop) then Ok()
				else Bad $ ("Error at" ++ (tokenPos2 $1) ++". Continue statement not in loop") 
			);}

--try catch
--il catch riceve l'ambiente in uscita del try, in modo da poter utilizzare variabili definite nel try
--il tac esegue il try, se ci sono eccezioni salta al catch altrimenti va al blocco successivo
  | 'try' Cmd 'catch' Cmd { 
			$$ = CmdTryCatch $2 $4;
			$2.isInLoop = $$.isInLoop; 
			$4.isInLoop = $$.isInLoop;
			$$.hasReturn = ($2.hasReturn && $4.hasReturn);
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;
			$2.envIn = (newEnv $$.envIn);
			$2.envInF = $$.envInF;
			$2.envInL = $$.envInL;
			$4.envIn = $2.envOut;
			$4.envInF = $$.envInF;
			$4.envInL = $$.envInL;
			$2.typFun = $$.typFun;
			$4.typFun = $$.typFun;

			$2.tempLab = $$.tempLab;
			$2.tempVar = $$.tempVar;
			$4.tempLab = ($2.tempLabOut+1);
			$4.tempVar = $2.tempVarOut;
			$$.tempLabOut = ($4.tempLabOut+1);
			$$.tempVarOut = $4.tempVarOut;
			$$.next = $$.tempLabOut;
			$2.endProc = $$.endProc;
			$4.endProc = $$.endProc;
			$$.tac = $2.tac++[OnExpJump $4.tempLab]++[UJump $$.next]++[Lab (show $4.tempLab)]++$4.tac++[Lab (show $$.next)];
			}


--elementi opzionali del ciclo for
ExpFor : 'by' ExpR { 	$$ = ExpFor_1 $2;
			$2.envIn = $$.envIn;
			$2.envInF = $$.envInF;
 			$$.err = $2.err;
			$$.typ = $2.typ;} 

  | '#' ExpR { 		$$ = ExpFor_2 $2;
			$2.envIn = $$.envIn;
			$2.envInF = $$.envInF;
 			$$.err = $2.err;
			$$.typ = $2.typ;}

  | '#' ExpR 'by' ExpR {$$ = ExpFor_3 $2 $4;
			$2.envIn = $$.envIn;
			$2.envInF = $$.envInF;
			$4.envIn = $$.envIn;
			$4.envInF = $$.envInF;
 			$$.err = $2.err ++ $4.err;
			$$.typ = genTypeList $2.typ $4.typ;}


BlockLoop : Cmd { 	$$ = BlockLoopCmd $1;
			$1.isInLoop = $$.isInLoop;
			$$.hasReturn = $1.hasReturn;
			$$.typ = $1.typ;
			$1.envIn = $$.envIn;
			$$.envOut = $1.envOut;
			$1.envInF = $$.envInF;
			$$.envOutF = $1.envOutF;
			$1.envInL = $$.envInL;
			$$.envOutL = $1.envOutL;
			$1.typFun = $$.typFun;
			
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$$.tempLabOut = $1.tempLabOut;
			$$.tempVarOut = $1.tempVarOut;
			$1.next = $$.next;
			$$.next = $$.tempLabOut;
			$1.beginLoop = $$.beginLoop;
			$1.endLoop = $$.endLoop;
			$1.endProc = $$.endProc;
			$$.tac = $1.tac;} 

  | 'do' CommSing { 	$$ = BlockLoop_2 $2;
			$2.isInLoop = $$.isInLoop;
			$$.hasReturn = $2.hasReturn;
			$$.typ = $2.typ;
			$2.envIn = $$.envIn;
			$$.envOut = $2.envOut;
			$2.envInF = $$.envInF;
			$$.envOutF = $2.envOutF;
			$2.envInL = $$.envInL;
			$$.envOutL = $2.envOutL;
			$2.typFun = $$.typFun;
			
			$2.tempLab = $$.tempLab;
			$2.tempVar = $$.tempVar;
			$$.tempLabOut = $2.tempLabOut;
			$$.tempVarOut = $2.tempVarOut;
			$2.next = $$.next;
			$$.next = $$.tempLabOut;
			$2.beginLoop = $$.beginLoop;
			$2.endLoop = $$.endLoop;
			$2.endProc = $$.endProc;
			$$.tac = $2.tac;}

--when usato nel select
When : 'when' ExpR BlockLoop { 
			$$ = CmdWhen $2 $3;
			$3.isInLoop = $$.isInLoop;
			$$.hasReturn = $3.hasReturn;
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;
			$2.envIn = $$.envIn;
			$2.envInF = $$.envInF;
			$2.envInL = $$.envInL;
			$3.envIn = (newEnv $$.envIn);
			$3.envInF = $$.envInF;
			$3.envInL = $$.envInL;
			$$.err = $2.err;
			$$.typ = $2.typ;
			$3.typFun = $$.typFun;

			$2.tempLab = $$.tempLab;
			$2.tempVar = $$.tempVar;
			$3.tempLab = ($2.tempLabOut);
			$3.tempVar = ($2.tempVarOut+1);
			$$.tempLabOut = ($3.tempLabOut+2);
			$$.tempVarOut = ($3.tempVarOut);
			$$.next = $$.tempLabOut;
			$$.addr = "t" ++ (show $$.tSelect);
			$3.beginLoop = $$.beginLoop;
			$3.endLoop = $$.endLoop;
			$3.endProc = $$.endProc;
			$$.isCond = False;
			$2.isCond = $$.isCond;
			$$.tac = [Lab (show $3.tempLabOut)]++$2.tac 
				++ [BinOp "==" ("t"++ (show $3.tempVar)) ("t"++(show $$.tSelect)) ("t"++(show $2.tempVarOut))] 
				++ [Jump $$.addr ($3.tempLabOut+1)]
				++ [JumpNot $$.addr ($$.tempLabOut)]++[Lab (show ($3.tempLabOut+1))]++$3.tac;} 



ListId : {- empty -} {$$ = [];} 
  | Id {$$ = (:[]) $1;}
  | Id ',' ListId { $$ = (:) $1 $3;}



ListCmd : {- empty -} { $$ = []; 
			$$.isInLoop = False;
			$$.hasReturn = False;
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL; 
			$$.tempLabOut = $$.tempLab;
			$$.tempVarOut = $$.tempVar;
			$$.next = $$.tempLabOut;
			$$.tac = [];}
 
  | ListCmd Cmd { 	$$ = flip (:) $1 $2;
			$1.isInLoop = $$.isInLoop;
			$2.isInLoop = $$.isInLoop;
			$$.hasReturn = $2.hasReturn;
			$1.envIn = $$.envIn;
			$2.envIn = $1.envOut; 
			$$.envOut = $2.envOut;
			$1.envInF = $$.envInF;
			$2.envInF = $1.envOutF;
			$$.envOutF = $2.envOutF;
			$1.envInL = $$.envInL;
			$2.envInL = $1.envOutL;
			$$.envOutL = $2.envOutL;
			$1.typFun = $$.typFun;
			$2.typFun = $$.typFun;
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$2.tempLab = $1.tempLabOut;
			$2.tempVar = $1.tempVarOut;
			$$.tempLabOut = $2.tempLabOut;
			$$.tempVarOut = $2.tempVarOut;
			$1.next = $$.next;
			$2.next = ($2.tempLabOut + 1);
			$$.next = $$.tempLabOut;
			$1.beginLoop = $$.beginLoop;
			$2.beginLoop = $$.beginLoop;
			$1.endLoop = $$.endLoop;
			$2.endLoop = $$.endLoop;
			$1.endProc = $$.endProc;
			$2.endProc = $$.endProc;
			$$.tac = $1.tac ++ $2.tac;}



ListExpR : {- empty -} {$$ = [];
			$$.typ = TypeVoid;
			$$.envIn = [];
			$$.paramList = [];
			$$.err = "";
			$$.tempLabOut = $$.tempLab;
			$$.tempVarOut = $$.tempVar;
			$$.next = $$.tempLabOut;
			$$.addrParamList = [];
			$$.tac = [];}
 
  | ExpR { 		$$ = (:[]) $1;
			$$.typ = $1.typ;
			$$.paramList = [$1.typ];
			$1.envIn = $$.envIn;
			$1.envInF = $$.envInF;
			$1.envInL = $$.envInL; 
			$$.err = $1.err;
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$$.tempLabOut = $1.tempLabOut;
			$$.tempVarOut = $1.tempVarOut;
			$$.next = $$.tempLabOut;
			$$.addrParamList = [$1.addr];
			$1.isCond = $$.isCond;
			$$.tac = $1.tac;}

  | ExpR ',' ListExpR {	$$ = (:) $1 $3;
			$$.typ = genTypeList $1.typ $3.typ;
			$$.paramList = ($1.typ : $3.paramList);
			$1.envIn = $$.envIn;
			$3.envIn = $$.envIn;
			$1.envInF = $$.envInF;
			$3.envInF = $$.envInF;
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL;
			$$.err = $1.err ++ $3.err;
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempLabOut = $3.tempLabOut;
			$$.tempVarOut = $3.tempVarOut;
			$$.next = $$.tempLabOut;
			$$.addrParamList = $1.addr : $3.addrParamList;
			$1.isCond = $$.isCond;
			$3.isCond = $$.isCond;
			$$.tac = $1.tac ++ $3.tac;}



ListParam : {- empty -} { 
			$$ = [];
			$$.envIn = []; 
			$$.paramList = [];}
 
  | Param { 		$$ = (:[]) $1;
			$$.envIn = $1.envIn;
			$$.paramList = $1.paramList;}

  | Param ',' ListParam { 
			$$ = (:) $1 $3;
			$$.envIn = $1.envIn ++ $3.envIn;
			$$.paramList = ( $1.paramList ++ $3.paramList ); 
			where ( case (checkVarParamList $1.envIn $3.envIn ) of {
					Just a  -> ( Bad $ "Sintax Error at "++(tokenPos2 $2)++": Duplicate identificator "++ getIdName a );
					Nothing -> ( Ok () );
				} );
			}


--when usati nel select
ListWhen : {- empty -} {$$ = [];
			$$.isInLoop = False;
			$$.hasReturn = False;
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;
			$$.typ = TypeVoid;
			$$.err = "";

			$$.tempLabOut = $$.tempLab;
			$$.tempVarOut = $$.tempVar;
			$$.tac = [];}

  | ListWhen When { 	$$ = flip (:) $1 $2; 
			$1.isInLoop = $$.isInLoop;
			$2.isInLoop = $$.isInLoop;
			$$.hasReturn = genHasReturnWhen $1 $2 $1.hasReturn $2.hasReturn;
			$$.envOut = $$.envIn;
			$$.envOutF = $$.envInF;
			$$.envOutL = $$.envInL;
			$1.envIn = $$.envIn;
			$1.envInF = $$.envInF;
			$1.envInL = $$.envInL;
			$2.envIn = $$.envIn;
			$2.envInF = $$.envInF;
			$2.envInL = $$.envInL;
			$$.typ = genTypeWhen $1.typ $2.typ;
			$1.typFun = $$.typFun;	
			$2.typFun = $$.typFun;
			$$.err = $1.err ++ $2.err;

			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$2.tempLab = $1.tempLabOut;
			$2.tempVar = $1.tempVarOut;
			$$.tempLabOut = $2.tempLabOut;
			$$.tempVarOut = $2.tempVarOut;
			$1.tSelect = $$.tSelect;
			$2.tSelect = $$.tSelect;
			$1.next = $$.next; 
			$2.next = $$.next;
			$1.beginLoop = $$.beginLoop;
			$2.beginLoop = $$.beginLoop;
			$1.endLoop = $$.endLoop;
			$2.endLoop = $$.endLoop;
			$1.endProc = $$.endProc;
			$2.endProc = $$.endProc;
			$$.tac = $1.tac ++ $2.tac ++ [UJump ($$.next)] ;}


ListExpRange : {- empty -} { 
			$$ = [];
			$$.typ = TypeVoid; 
			$$.err = "";} 

  | ExpRange { 		$$ = (:[]) $1;
			$$.typ = $1.typ;
			$1.envIn = $$.envIn;
			$1.envInF = $$.envInF;
			$$.err = $1.err;
			}

  | ExpRange ',' ListExpRange { 
			$$ = (:) $1 $3; 
			$$.typ = genTypeList $1.typ $3.typ;
			$1.envIn = $$.envIn;
			$1.envInF = $$.envInF;
			$3.envIn = $$.envIn;
			$3.envInF = $$.envInF;
			$$.err = $1.err ++ $3.err;}
--da togliere lista vuota
ListExpArrayElem : ExpArrayElem { 
			$$ = (:[]) $1 ;
			$$.typ = $1.typ;
			$$.paramList = [$1.typ];
			$1.envIn = $$.envIn;
			$1.envInF = $$.envInF;
			$1.envInL = $$.envInL; 
			$$.err = $1.err;
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$$.tempLabOut = $1.tempLabOut;
			$$.tempVarOut = $1.tempVarOut;
			$$.next = $$.tempLabOut;
			$$.addrParamList = $1.addrParamList;
			$1.isCond = $$.isCond;
			$$.tac = $1.tac;}

  | ExpArrayElem ',' ListExpArrayElem { 
			$$ = (:) $1 $3 ;
			$$.typ = genTypeList $1.typ $3.typ;
			$$.paramList = ($1.typ : $3.paramList);
			$1.envIn = $$.envIn;
			$3.envIn = $$.envIn;
			$1.envInF = $$.envInF;
			$3.envInF = $$.envInF;
			$1.envInL = $$.envInL;
			$3.envInL = $$.envInL;
			$$.err = $1.err ++ $3.err;
			$1.tempLab = $$.tempLab;
			$1.tempVar = $$.tempVar;
			$3.tempLab = $1.tempLabOut;
			$3.tempVar = $1.tempVarOut;
			$$.tempLabOut = $3.tempLabOut;
			$$.tempVarOut = $3.tempVarOut;
			$$.next = $$.tempLabOut;
			$$.addrParamList = $1.addrParamList ++ $3.addrParamList;
			$1.isCond = $$.isCond;
			$3.isCond = $$.isCond;
			$$.tac = $1.tac ++ $3.tac;}

{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

